<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI PDF Flipbook (Final Stable Version with OCR)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/page-flip/dist/js/page-flip.browser.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <script src='https://unpkg.com/tesseract.js@5.0.3/dist/tesseract.min.js'></script> 

    <style>
        /* CSS Reset & Layout */
        body {
            background-color: #2b2b2b;
            color: #f0f0f0;
            font-family: 'Sarabun', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; 
        }

        /* Control Panel */
        .controls {
            margin-bottom: 15px;
            padding: 10px 20px;
            background: #3e3e3e;
            border-radius: 10px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            z-index: 100;
        }

        /* Inputs & Buttons */
        select, button, label {
            font-size: 14px;
            cursor: pointer;
        }

        select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background: #eee;
            color: #333;
            max-width: 250px;
        }

        button {
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            background-color: #007bff;
            color: white;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) { transform: translateY(-1px); filter: brightness(1.1); }
        button:disabled { background-color: #666; cursor: not-allowed; opacity: 0.7; }
        
        .btn-stop { background-color: #dc3545; }
        .divider { width: 1px; height: 25px; background: #666; margin: 0 5px; }

        /* Book Container */
        .book-wrapper {
            width: 100%;
            height: 75vh; 
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        /* Canvas Style - แก้บัคภาพสั่น */
        canvas {
            display: block; 
            margin: 0 auto;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        /* ปรับแต่ง Shadow ของ Library */
        .stf__block {
            filter: drop-shadow(0 0 10px rgba(0,0,0,0.3));
        }

        #ttsStatus { font-size: 0.85em; color: #aaa; margin-left: 5px; }
        
        /* Loading Overlay */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); color: white;
            display: none; justify-content: center; align-items: center; flex-direction: column;
            z-index: 999;
        }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <div id="loadingText">กำลังประมวลผล PDF...</div>
    </div>

    <div class="controls">
        <label class="btn-upload">
            <i class="fas fa-file-pdf"></i> เลือก PDF
            <input type="file" id="upload" accept="application/pdf" style="display:none;" />
        </label>
        
        <div style="display:flex; align-items:center; gap:5px;">
            <input type="checkbox" id="splitPages" checked>
            <label for="splitPages">ตัดหน้าคู่</label>
        </div>

        <div class="divider"></div>

        <select id="voiceSelect"><option value="">กำลังโหลดเสียง...</option></select>
        
        <button id="btnRead" disabled><i class="fas fa-volume-up"></i> อ่าน</button>
        <button id="btnStop" class="btn-stop" style="display:none;"><i class="fas fa-stop"></i> หยุด</button>
        
        <span id="ttsStatus"></span>
    </div>

    <div class="book-wrapper">
        <div id="book"></div>
    </div>

    <script>
        // Setup PDF.js Worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // DOM Elements
        const uploadInput = document.getElementById('upload');
        const splitCheckbox = document.getElementById('splitPages');
        const bookElement = document.getElementById('book');
        const voiceSelect = document.getElementById('voiceSelect');
        const btnRead = document.getElementById('btnRead');
        const btnStop = document.getElementById('btnStop');
        const ttsStatus = document.getElementById('ttsStatus');
        const loadingScreen = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');

        // Variables
        let pageFlip;
        let pageTexts = [];
        let synth = window.speechSynthesis;
        let voices = [];

        // *** 2. ฟังก์ชัน OCR (Tesseract.js) ***
        async function runOCR(imageCanvas, langCode = 'tha+eng') {
            try {
                // Tesseract.js จะรับ Canvas มาประมวลผลโดยตรง
                const worker = await Tesseract.createWorker(langCode);
                const { data: { text } } = await worker.recognize(imageCanvas);
                await worker.terminate();
                
                return text.replace(/\s+/g, ' ').trim();

            } catch (error) {
                console.error("Tesseract OCR Error:", error);
                return "";
            }
        }
        
        // --- ระบบเสียง (TTS) ---

        function loadVoices() {
            voices = synth.getVoices();
            voiceSelect.innerHTML = '';
            
            voices.sort((a, b) => {
                const isThaiA = a.lang.includes('th');
                const isThaiB = b.lang.includes('th');
                if (isThaiA && !isThaiB) return -1;
                if (!isThaiA && isThaiB) return 1;
                return 0;
            });

            voices.forEach(voice => {
                const option = document.createElement('option');
                option.textContent = `${voice.name} (${voice.lang})`;
                option.value = voice.name;
                if(voice.lang.includes('th-TH') || voice.lang.includes('th_TH')) option.selected = true;
                voiceSelect.appendChild(option);
            });
        }

        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = loadVoices;
        }
        loadVoices();

        function speak(text) {
            if (synth.speaking) synth.cancel();
            
            let cleanText = text.replace(/\s+/g, ' ').trim();
            
            if (!cleanText) {
                ttsStatus.textContent = "(ไม่พบข้อความในหน้านี้)";
                setTimeout(() => ttsStatus.textContent = "", 3000);
                return;
            }

            const utterance = new SpeechSynthesisUtterance(cleanText);
            const selectedVoice = voices.find(v => v.name === voiceSelect.value);
            if (selectedVoice) utterance.voice = selectedVoice;
            
            utterance.rate = 1.0; 
            utterance.pitch = 1.0;

            utterance.onstart = () => {
                btnRead.style.display = 'none';
                btnStop.style.display = 'flex';
                ttsStatus.textContent = "กำลังอ่าน...";
            };
            utterance.onend = () => {
                btnRead.style.display = 'flex';
                btnStop.style.display = 'none';
                ttsStatus.textContent = "";
            };
            utterance.onerror = (event) => {
                console.error("TTS Error:", event);
                ttsStatus.textContent = "เกิดข้อผิดพลาดในการอ่านเสียง";
                btnRead.style.display = 'flex';
                btnStop.style.display = 'none';
            };

            synth.speak(utterance);
        }

        btnRead.addEventListener('click', () => {
            if (!pageFlip || btnRead.disabled) return;
            
            const index = pageFlip.getCurrentPageIndex();
            const orient = pageFlip.getOrientation(); 
            
            let textToRead = pageTexts[index] || "";

            if (orient === 'landscape' && (index + 1) < pageTexts.length) {
                textToRead += " " + (pageTexts[index + 1] || "");
            }

            speak(textToRead);
        });

        btnStop.addEventListener('click', () => {
            synth.cancel();
            btnRead.style.display = 'flex';
            btnStop.style.display = 'none';
            ttsStatus.textContent = "";
        });

        // --- ระบบ PDF & Render ---

        uploadInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file || file.type !== 'application/pdf') {
                alert('กรุณาเลือกไฟล์ PDF');
                return;
            }

            loadingScreen.style.display = 'flex';
            btnRead.disabled = true;

            const reader = new FileReader();
            reader.onload = async function() {
                try {
                    const typedarray = new Uint8Array(this.result);
                    await renderPDF(typedarray);
                    btnRead.disabled = false;
                } catch (err) {
                    console.error("PDF Loading Error in getDocument or renderPDF:", err);
                    alert("เกิดข้อผิดพลาดในการโหลดหรืออ่านไฟล์ PDF (กรุณาลองไฟล์อื่น)");
                } finally {
                    loadingScreen.style.display = 'none';
                }
            };
            reader.readAsArrayBuffer(file);
        });

        async function renderPDF(data) {
            // Reset
            bookElement.innerHTML = '';
            pageTexts = [];
            if (pageFlip) { pageFlip.destroy(); pageFlip = null; }
            if (synth.speaking) synth.cancel();

            const pdf = await pdfjsLib.getDocument(data).promise;
            const shouldSplit = splitCheckbox.checked;
            
            const RENDER_SCALE = 1.0; 

            // ตัวแปรสำหรับเก็บข้อมูลปกหลัง (Fixed: TypeError)
            let backCoverData = null; 
            let backCoverText = "";

            // คำนวณขนาดจากหน้าแรก
            const firstPage = await pdf.getPage(1);
            const vp = firstPage.getViewport({ scale: RENDER_SCALE });
            
            const fullW = vp.width;
            const fullH = vp.height;

            const singleW = shouldSplit ? fullW / 2 : fullW;
            const singleH = fullH;

            const MAX_DIMENSION = 800; 
            let adjustedRatio = 1.0;
            if (singleW > MAX_DIMENSION) {
                adjustedRatio = MAX_DIMENSION / singleW;
            }
            
            const adjustedW = singleW * adjustedRatio;
            const adjustedH = singleH * adjustedRatio;
            const midX = fullW / 2;


            // Loop ทุกหน้า
            for (let i = 1; i <= pdf.numPages; i++) {
                loadingText.textContent = `กำลังแปลงหน้า ${i} / ${pdf.numPages}...`;
                
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: RENDER_SCALE });

                // 1. สร้าง Canvas ชั่วคราว (Hidden) เพื่อ Render หน้าเต็ม PDF 
                const tempCanvas = createPageCanvas(fullW, fullH);
                await page.render({ canvasContext: tempCanvas.getContext('2d'), viewport }).promise;
                
                // 2. ดึง Text
                const textContent = await page.getTextContent();
                let textL = "", textR = "";

                if (shouldSplit) {
                    textContent.items.forEach(item => {
                        const x = item.transform[4]; 
                        const str = item.str + " ";
                        (x < midX) ? textL += str : textR += str;
                    });
                } else {
                    textL = textContent.items.map(item => item.str).join(' ');
                }

                
                // *** 3. OCR FALLBACK LOGIC ***
                // ถ้าไม่พบข้อความเลย (ไฟล์สแกน) ให้รัน OCR
                if (textL.trim() === "" && textR.trim() === "") {
                    loadingText.textContent = `กำลังแปลงหน้า ${i} (OCR Fallback)...`;
                    
                    const fullText = await runOCR(tempCanvas);
                    
                    if (shouldSplit) {
                        // โหมดตัดหน้า: OCR มักแยกซ้ายขวาไม่ได้แม่นยำ 
                        // เราจึงรวมข้อความ OCR ไว้ใน textL และให้ TTS อ่านรวมกัน
                        textL = fullText;
                        textR = "";
                    } else {
                        // โหมดปกติ
                        textL = fullText;
                    }
                }
                
                // 4. สร้าง Canvas สุดท้ายสำหรับแสดงผล (Adjusted Size)
                
                if (shouldSplit) {
                    // === โหมดตัดหน้าคู่ ===
                    
                    if (i === 1) {
                        // ปกหลัง (ซ้าย) -> เก็บ Canvas ชั่วคราว และ Text ไว้
                        let tempCanvasData = tempCanvas; 
                        backCoverText = textL; // TextL (ปกหลัง) ถูกดึง/OCR มาแล้ว

                        // ปกหน้า (ขวา) -> สร้าง Final Canvas และตัดเอาส่วนขวามา
                        const cFront = createPageCanvas(adjustedW, adjustedH);
                        const ctx = cFront.getContext('2d');
                        
                        // ตัดส่วนขวา: เริ่มตัดจาก x กลางหน้า (midX)
                        ctx.drawImage(tempCanvasData, midX, 0, midX, fullH, 0, 0, adjustedW, adjustedH);
                        
                        bookElement.appendChild(cFront);
                        pageTexts.push(textR);
                        
                        // เก็บ Canvas เต็มใบไว้ใน backCoverData เพื่อใช้เป็นปกหลัง
                        backCoverData = tempCanvasData; 
                        tempCanvasData = null; 

                    } else {
                        // หน้าเนื้อหา: ซ้าย -> ขวา
                        
                        // 1. ซ้าย: ตัดจาก (0, 0)
                        const cL = createPageCanvas(adjustedW, adjustedH);
                        cL.getContext('2d').drawImage(tempCanvas, 0, 0, midX, fullH, 0, 0, adjustedW, adjustedH);
                        bookElement.appendChild(cL);
                        pageTexts.push(textL);

                        // 2. ขวา: ตัดจาก (midX, 0)
                        const cR = createPageCanvas(adjustedW, adjustedH);
                        cR.getContext('2d').drawImage(tempCanvas, midX, 0, midX, fullH, 0, 0, adjustedW, adjustedH);
                        bookElement.appendChild(cR);
                        pageTexts.push(textR);
                    }
                } else {
                    // === โหมดปกติ (ไม่ตัดหน้า) ===
                    const canvas = createPageCanvas(adjustedW, adjustedH);
                    canvas.getContext('2d').drawImage(tempCanvas, 0, 0, fullW, fullH, 0, 0, adjustedW, adjustedH);
                    bookElement.appendChild(canvas);
                    pageTexts.push(textL);
                }
            }

            // 5. แปะปกหลัง (ถ้ามี)
            if (shouldSplit && backCoverData) { 
                const finalBack = createPageCanvas(adjustedW, adjustedH);
                const ctx = finalBack.getContext('2d');
                
                // ปกหลังคือส่วนซ้ายของหน้า 1
                ctx.drawImage(backCoverData, 0, 0, midX, fullH, 0, 0, adjustedW, adjustedH);
                
                bookElement.appendChild(finalBack);
                pageTexts.push(backCoverText);
            }

            // 6. FIX JITTER: แก้บัคกระตุกด้วยการเช็คเลขคู่
            if (bookElement.children.length % 2 !== 0) {
                const blankPage = createPageCanvas(adjustedW, adjustedH);
                blankPage.getContext('2d').fillStyle = "white"; 
                blankPage.getContext('2d').fillRect(0,0, adjustedW, adjustedH);
                bookElement.appendChild(blankPage);
                pageTexts.push(""); 
            }

            initFlipBook(adjustedW, adjustedH);
        }

        // Helper สร้าง Canvas เปล่า
        function createPageCanvas(w, h) {
            const c = document.createElement('canvas');
            c.width = w;
            c.height = h;
            return c;
        }

        function initFlipBook(w, h) {
            pageFlip = new St.PageFlip(bookElement, {
                width: w,
                height: h,
                size: 'fixed', 
                
                minWidth: 300, 
                maxWidth: w,
                minHeight: 400, 
                maxHeight: h,
                
                showCover: true,
                maxShadowOpacity: 0.2, 
                autoSize: true, 
                mobileScrollSupport: false
            });

            pageFlip.loadFromHTML(document.querySelectorAll("canvas"));

            // Event: หยุดเสียงเมื่อพลิกหน้า
            pageFlip.on('flip', (e) => {
                if (synth.speaking) {
                    synth.cancel();
                    btnRead.style.display = 'flex';
                    btnStop.style.display = 'none';
                    ttsStatus.textContent = "";
                }
            });
        }
    </script>
</body>
</html>